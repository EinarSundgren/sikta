// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entities.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEntitiesBySource = `-- name: CountEntitiesBySource :one
SELECT COUNT(*) FROM entities WHERE source_id = $1
`

func (q *Queries) CountEntitiesBySource(ctx context.Context, sourceID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEntitiesBySource, sourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEntitiesByStatusForSource = `-- name: CountEntitiesByStatusForSource :many
SELECT review_status, COUNT(*) AS count
FROM entities
WHERE source_id = $1
GROUP BY review_status
`

type CountEntitiesByStatusForSourceRow struct {
	ReviewStatus string `json:"review_status"`
	Count        int64  `json:"count"`
}

func (q *Queries) CountEntitiesByStatusForSource(ctx context.Context, sourceID pgtype.UUID) ([]*CountEntitiesByStatusForSourceRow, error) {
	rows, err := q.db.Query(ctx, countEntitiesByStatusForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CountEntitiesByStatusForSourceRow{}
	for rows.Next() {
		var i CountEntitiesByStatusForSourceRow
		if err := rows.Scan(&i.ReviewStatus, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createEntity = `-- name: CreateEntity :one
INSERT INTO entities (
    source_id, name, entity_type, aliases, description,
    first_appearance_chunk, last_appearance_chunk, confidence, metadata
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, source_id, name, entity_type, aliases, description, first_appearance_chunk, last_appearance_chunk, confidence, review_status, metadata, created_at, updated_at
`

type CreateEntityParams struct {
	SourceID             pgtype.UUID `json:"source_id"`
	Name                 string      `json:"name"`
	EntityType           string      `json:"entity_type"`
	Aliases              []string    `json:"aliases"`
	Description          pgtype.Text `json:"description"`
	FirstAppearanceChunk pgtype.Int4 `json:"first_appearance_chunk"`
	LastAppearanceChunk  pgtype.Int4 `json:"last_appearance_chunk"`
	Confidence           float32     `json:"confidence"`
	Metadata             []byte      `json:"metadata"`
}

func (q *Queries) CreateEntity(ctx context.Context, arg CreateEntityParams) (*Entity, error) {
	row := q.db.QueryRow(ctx, createEntity,
		arg.SourceID,
		arg.Name,
		arg.EntityType,
		arg.Aliases,
		arg.Description,
		arg.FirstAppearanceChunk,
		arg.LastAppearanceChunk,
		arg.Confidence,
		arg.Metadata,
	)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Name,
		&i.EntityType,
		&i.Aliases,
		&i.Description,
		&i.FirstAppearanceChunk,
		&i.LastAppearanceChunk,
		&i.Confidence,
		&i.ReviewStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEntity = `-- name: GetEntity :one
SELECT id, source_id, name, entity_type, aliases, description, first_appearance_chunk, last_appearance_chunk, confidence, review_status, metadata, created_at, updated_at FROM entities WHERE id = $1
`

func (q *Queries) GetEntity(ctx context.Context, id pgtype.UUID) (*Entity, error) {
	row := q.db.QueryRow(ctx, getEntity, id)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Name,
		&i.EntityType,
		&i.Aliases,
		&i.Description,
		&i.FirstAppearanceChunk,
		&i.LastAppearanceChunk,
		&i.Confidence,
		&i.ReviewStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listEntitiesBySource = `-- name: ListEntitiesBySource :many
SELECT id, source_id, name, entity_type, aliases, description, first_appearance_chunk, last_appearance_chunk, confidence, review_status, metadata, created_at, updated_at FROM entities WHERE source_id = $1 ORDER BY first_appearance_chunk
`

func (q *Queries) ListEntitiesBySource(ctx context.Context, sourceID pgtype.UUID) ([]*Entity, error) {
	rows, err := q.db.Query(ctx, listEntitiesBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Name,
			&i.EntityType,
			&i.Aliases,
			&i.Description,
			&i.FirstAppearanceChunk,
			&i.LastAppearanceChunk,
			&i.Confidence,
			&i.ReviewStatus,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntityAliases = `-- name: UpdateEntityAliases :one
UPDATE entities
SET aliases = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, source_id, name, entity_type, aliases, description, first_appearance_chunk, last_appearance_chunk, confidence, review_status, metadata, created_at, updated_at
`

type UpdateEntityAliasesParams struct {
	ID      pgtype.UUID `json:"id"`
	Aliases []string    `json:"aliases"`
}

func (q *Queries) UpdateEntityAliases(ctx context.Context, arg UpdateEntityAliasesParams) (*Entity, error) {
	row := q.db.QueryRow(ctx, updateEntityAliases, arg.ID, arg.Aliases)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Name,
		&i.EntityType,
		&i.Aliases,
		&i.Description,
		&i.FirstAppearanceChunk,
		&i.LastAppearanceChunk,
		&i.Confidence,
		&i.ReviewStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateEntityReviewStatus = `-- name: UpdateEntityReviewStatus :one
UPDATE entities
SET review_status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, source_id, name, entity_type, aliases, description, first_appearance_chunk, last_appearance_chunk, confidence, review_status, metadata, created_at, updated_at
`

type UpdateEntityReviewStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	ReviewStatus string      `json:"review_status"`
}

func (q *Queries) UpdateEntityReviewStatus(ctx context.Context, arg UpdateEntityReviewStatusParams) (*Entity, error) {
	row := q.db.QueryRow(ctx, updateEntityReviewStatus, arg.ID, arg.ReviewStatus)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Name,
		&i.EntityType,
		&i.Aliases,
		&i.Description,
		&i.FirstAppearanceChunk,
		&i.LastAppearanceChunk,
		&i.Confidence,
		&i.ReviewStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
