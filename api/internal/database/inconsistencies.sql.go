// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inconsistencies.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInconsistenciesBySource = `-- name: CountInconsistenciesBySource :one
SELECT
    COUNT(*) as total,
    SUM(CASE WHEN severity = 'conflict' THEN 1 ELSE 0 END) as conflicts,
    SUM(CASE WHEN severity = 'warning' THEN 1 ELSE 0 END) as warnings,
    SUM(CASE WHEN severity = 'info' THEN 1 ELSE 0 END) as info
FROM inconsistencies
WHERE source_id = $1
`

type CountInconsistenciesBySourceRow struct {
	Total     int64 `json:"total"`
	Conflicts int64 `json:"conflicts"`
	Warnings  int64 `json:"warnings"`
	Info      int64 `json:"info"`
}

func (q *Queries) CountInconsistenciesBySource(ctx context.Context, sourceID pgtype.UUID) (*CountInconsistenciesBySourceRow, error) {
	row := q.db.QueryRow(ctx, countInconsistenciesBySource, sourceID)
	var i CountInconsistenciesBySourceRow
	err := row.Scan(
		&i.Total,
		&i.Conflicts,
		&i.Warnings,
		&i.Info,
	)
	return &i, err
}

const createInconsistency = `-- name: CreateInconsistency :one
INSERT INTO inconsistencies (id, source_id, inconsistency_type, severity, title, description, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, source_id, inconsistency_type, severity, title, description, resolution_status, resolution_note, metadata, created_at, updated_at
`

type CreateInconsistencyParams struct {
	ID                pgtype.UUID `json:"id"`
	SourceID          pgtype.UUID `json:"source_id"`
	InconsistencyType string      `json:"inconsistency_type"`
	Severity          string      `json:"severity"`
	Title             string      `json:"title"`
	Description       string      `json:"description"`
	Metadata          []byte      `json:"metadata"`
}

func (q *Queries) CreateInconsistency(ctx context.Context, arg CreateInconsistencyParams) (*Inconsistency, error) {
	row := q.db.QueryRow(ctx, createInconsistency,
		arg.ID,
		arg.SourceID,
		arg.InconsistencyType,
		arg.Severity,
		arg.Title,
		arg.Description,
		arg.Metadata,
	)
	var i Inconsistency
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.InconsistencyType,
		&i.Severity,
		&i.Title,
		&i.Description,
		&i.ResolutionStatus,
		&i.ResolutionNote,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createInconsistencyItem = `-- name: CreateInconsistencyItem :one
INSERT INTO inconsistency_items (id, inconsistency_id, claim_id, entity_id, side, description)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, inconsistency_id, claim_id, entity_id, side, description, created_at
`

type CreateInconsistencyItemParams struct {
	ID              pgtype.UUID `json:"id"`
	InconsistencyID pgtype.UUID `json:"inconsistency_id"`
	ClaimID         pgtype.UUID `json:"claim_id"`
	EntityID        pgtype.UUID `json:"entity_id"`
	Side            pgtype.Text `json:"side"`
	Description     pgtype.Text `json:"description"`
}

func (q *Queries) CreateInconsistencyItem(ctx context.Context, arg CreateInconsistencyItemParams) (*InconsistencyItem, error) {
	row := q.db.QueryRow(ctx, createInconsistencyItem,
		arg.ID,
		arg.InconsistencyID,
		arg.ClaimID,
		arg.EntityID,
		arg.Side,
		arg.Description,
	)
	var i InconsistencyItem
	err := row.Scan(
		&i.ID,
		&i.InconsistencyID,
		&i.ClaimID,
		&i.EntityID,
		&i.Side,
		&i.Description,
		&i.CreatedAt,
	)
	return &i, err
}

const getInconsistency = `-- name: GetInconsistency :one
SELECT id, source_id, inconsistency_type, severity, title, description, resolution_status, resolution_note, metadata, created_at, updated_at FROM inconsistencies
WHERE id = $1
`

func (q *Queries) GetInconsistency(ctx context.Context, id pgtype.UUID) (*Inconsistency, error) {
	row := q.db.QueryRow(ctx, getInconsistency, id)
	var i Inconsistency
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.InconsistencyType,
		&i.Severity,
		&i.Title,
		&i.Description,
		&i.ResolutionStatus,
		&i.ResolutionNote,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listInconsistenciesByClaim = `-- name: ListInconsistenciesByClaim :many
SELECT i.id, i.source_id, i.inconsistency_type, i.severity, i.title, i.description, i.resolution_status, i.resolution_note, i.metadata, i.created_at, i.updated_at
FROM inconsistencies i
INNER JOIN inconsistency_items ii ON i.id = ii.inconsistency_id
WHERE ii.claim_id = $1
ORDER BY
    CASE i.severity
        WHEN 'conflict' THEN 1
        WHEN 'warning' THEN 2
        WHEN 'info' THEN 3
    END,
    i.created_at DESC
`

func (q *Queries) ListInconsistenciesByClaim(ctx context.Context, claimID pgtype.UUID) ([]*Inconsistency, error) {
	rows, err := q.db.Query(ctx, listInconsistenciesByClaim, claimID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Inconsistency{}
	for rows.Next() {
		var i Inconsistency
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.InconsistencyType,
			&i.Severity,
			&i.Title,
			&i.Description,
			&i.ResolutionStatus,
			&i.ResolutionNote,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInconsistenciesBySource = `-- name: ListInconsistenciesBySource :many
SELECT id, source_id, inconsistency_type, severity, title, description, resolution_status, resolution_note, metadata, created_at, updated_at FROM inconsistencies
WHERE source_id = $1
ORDER BY
    CASE severity
        WHEN 'conflict' THEN 1
        WHEN 'warning' THEN 2
        WHEN 'info' THEN 3
    END,
    created_at DESC
`

func (q *Queries) ListInconsistenciesBySource(ctx context.Context, sourceID pgtype.UUID) ([]*Inconsistency, error) {
	rows, err := q.db.Query(ctx, listInconsistenciesBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Inconsistency{}
	for rows.Next() {
		var i Inconsistency
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.InconsistencyType,
			&i.Severity,
			&i.Title,
			&i.Description,
			&i.ResolutionStatus,
			&i.ResolutionNote,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInconsistencyItems = `-- name: ListInconsistencyItems :many
SELECT
    ii.id, ii.inconsistency_id, ii.claim_id, ii.entity_id, ii.side, ii.description, ii.created_at,
    c.title as claim_title,
    c.event_type,
    en.name as entity_name,
    en.entity_type
FROM inconsistency_items ii
LEFT JOIN claims c ON ii.claim_id = c.id
LEFT JOIN entities en ON ii.entity_id = en.id
WHERE ii.inconsistency_id = $1
ORDER BY ii.side, ii.id
`

type ListInconsistencyItemsRow struct {
	ID              pgtype.UUID        `json:"id"`
	InconsistencyID pgtype.UUID        `json:"inconsistency_id"`
	ClaimID         pgtype.UUID        `json:"claim_id"`
	EntityID        pgtype.UUID        `json:"entity_id"`
	Side            pgtype.Text        `json:"side"`
	Description     pgtype.Text        `json:"description"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ClaimTitle      pgtype.Text        `json:"claim_title"`
	EventType       pgtype.Text        `json:"event_type"`
	EntityName      pgtype.Text        `json:"entity_name"`
	EntityType      pgtype.Text        `json:"entity_type"`
}

func (q *Queries) ListInconsistencyItems(ctx context.Context, inconsistencyID pgtype.UUID) ([]*ListInconsistencyItemsRow, error) {
	rows, err := q.db.Query(ctx, listInconsistencyItems, inconsistencyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListInconsistencyItemsRow{}
	for rows.Next() {
		var i ListInconsistencyItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.InconsistencyID,
			&i.ClaimID,
			&i.EntityID,
			&i.Side,
			&i.Description,
			&i.CreatedAt,
			&i.ClaimTitle,
			&i.EventType,
			&i.EntityName,
			&i.EntityType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInconsistencyResolution = `-- name: UpdateInconsistencyResolution :one
UPDATE inconsistencies
SET resolution_status = $2,
    resolution_note = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, source_id, inconsistency_type, severity, title, description, resolution_status, resolution_note, metadata, created_at, updated_at
`

type UpdateInconsistencyResolutionParams struct {
	ID               pgtype.UUID `json:"id"`
	ResolutionStatus string      `json:"resolution_status"`
	ResolutionNote   pgtype.Text `json:"resolution_note"`
}

func (q *Queries) UpdateInconsistencyResolution(ctx context.Context, arg UpdateInconsistencyResolutionParams) (*Inconsistency, error) {
	row := q.db.QueryRow(ctx, updateInconsistencyResolution, arg.ID, arg.ResolutionStatus, arg.ResolutionNote)
	var i Inconsistency
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.InconsistencyType,
		&i.Severity,
		&i.Title,
		&i.Description,
		&i.ResolutionStatus,
		&i.ResolutionNote,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
