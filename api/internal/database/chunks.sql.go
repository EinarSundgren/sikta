// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunks.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countChunksBySource = `-- name: CountChunksBySource :one
SELECT COUNT(*) FROM chunks WHERE source_id = $1
`

func (q *Queries) CountChunksBySource(ctx context.Context, sourceID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChunksBySource, sourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (
    source_id, chunk_index, content, chapter_title,
    chapter_number, page_start, page_end, narrative_position, word_count
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, chunk_index, chapter_title, chapter_number
`

type CreateChunkParams struct {
	SourceID          pgtype.UUID `json:"source_id"`
	ChunkIndex        int32       `json:"chunk_index"`
	Content           string      `json:"content"`
	ChapterTitle      pgtype.Text `json:"chapter_title"`
	ChapterNumber     pgtype.Int4 `json:"chapter_number"`
	PageStart         pgtype.Int4 `json:"page_start"`
	PageEnd           pgtype.Int4 `json:"page_end"`
	NarrativePosition int32       `json:"narrative_position"`
	WordCount         pgtype.Int4 `json:"word_count"`
}

type CreateChunkRow struct {
	ID            pgtype.UUID `json:"id"`
	ChunkIndex    int32       `json:"chunk_index"`
	ChapterTitle  pgtype.Text `json:"chapter_title"`
	ChapterNumber pgtype.Int4 `json:"chapter_number"`
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (*CreateChunkRow, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.SourceID,
		arg.ChunkIndex,
		arg.Content,
		arg.ChapterTitle,
		arg.ChapterNumber,
		arg.PageStart,
		arg.PageEnd,
		arg.NarrativePosition,
		arg.WordCount,
	)
	var i CreateChunkRow
	err := row.Scan(
		&i.ID,
		&i.ChunkIndex,
		&i.ChapterTitle,
		&i.ChapterNumber,
	)
	return &i, err
}

const getChunk = `-- name: GetChunk :one
SELECT id, source_id, chunk_index, content, chapter_title, chapter_number, page_start, page_end, narrative_position, word_count, created_at FROM chunks WHERE id = $1
`

func (q *Queries) GetChunk(ctx context.Context, id pgtype.UUID) (*Chunk, error) {
	row := q.db.QueryRow(ctx, getChunk, id)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.ChunkIndex,
		&i.Content,
		&i.ChapterTitle,
		&i.ChapterNumber,
		&i.PageStart,
		&i.PageEnd,
		&i.NarrativePosition,
		&i.WordCount,
		&i.CreatedAt,
	)
	return &i, err
}

const listChunksBySource = `-- name: ListChunksBySource :many
SELECT id, source_id, chunk_index, content, chapter_title, chapter_number, page_start, page_end, narrative_position, word_count, created_at FROM chunks WHERE source_id = $1 ORDER BY chunk_index
`

func (q *Queries) ListChunksBySource(ctx context.Context, sourceID pgtype.UUID) ([]*Chunk, error) {
	rows, err := q.db.Query(ctx, listChunksBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.ChunkIndex,
			&i.Content,
			&i.ChapterTitle,
			&i.ChapterNumber,
			&i.PageStart,
			&i.PageEnd,
			&i.NarrativePosition,
			&i.WordCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
