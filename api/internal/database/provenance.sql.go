// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: provenance.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProvenanceByModality = `-- name: CountProvenanceByModality :one
SELECT modality, COUNT(*) as count
FROM provenance
GROUP BY modality
ORDER BY count DESC
`

type CountProvenanceByModalityRow struct {
	Modality string `json:"modality"`
	Count    int64  `json:"count"`
}

func (q *Queries) CountProvenanceByModality(ctx context.Context) (*CountProvenanceByModalityRow, error) {
	row := q.db.QueryRow(ctx, countProvenanceByModality)
	var i CountProvenanceByModalityRow
	err := row.Scan(&i.Modality, &i.Count)
	return &i, err
}

const countProvenanceByStatus = `-- name: CountProvenanceByStatus :one
SELECT status, COUNT(*) as count
FROM provenance
GROUP BY status
ORDER BY count DESC
`

type CountProvenanceByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountProvenanceByStatus(ctx context.Context) (*CountProvenanceByStatusRow, error) {
	row := q.db.QueryRow(ctx, countProvenanceByStatus)
	var i CountProvenanceByStatusRow
	err := row.Scan(&i.Status, &i.Count)
	return &i, err
}

const createProvenance = `-- name: CreateProvenance :one
INSERT INTO provenance (
    target_type, target_id, source_id, excerpt, location,
    confidence, trust, status, modality,
    claimed_time_start, claimed_time_end, claimed_time_text,
    claimed_geo_region, claimed_geo_text, claimed_by
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
RETURNING id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at
`

type CreateProvenanceParams struct {
	TargetType       string             `json:"target_type"`
	TargetID         pgtype.UUID        `json:"target_id"`
	SourceID         pgtype.UUID        `json:"source_id"`
	Excerpt          string             `json:"excerpt"`
	Location         []byte             `json:"location"`
	Confidence       float32            `json:"confidence"`
	Trust            float32            `json:"trust"`
	Status           string             `json:"status"`
	Modality         string             `json:"modality"`
	ClaimedTimeStart pgtype.Timestamptz `json:"claimed_time_start"`
	ClaimedTimeEnd   pgtype.Timestamptz `json:"claimed_time_end"`
	ClaimedTimeText  pgtype.Text        `json:"claimed_time_text"`
	ClaimedGeoRegion pgtype.Text        `json:"claimed_geo_region"`
	ClaimedGeoText   pgtype.Text        `json:"claimed_geo_text"`
	ClaimedBy        pgtype.UUID        `json:"claimed_by"`
}

func (q *Queries) CreateProvenance(ctx context.Context, arg CreateProvenanceParams) (*Provenance, error) {
	row := q.db.QueryRow(ctx, createProvenance,
		arg.TargetType,
		arg.TargetID,
		arg.SourceID,
		arg.Excerpt,
		arg.Location,
		arg.Confidence,
		arg.Trust,
		arg.Status,
		arg.Modality,
		arg.ClaimedTimeStart,
		arg.ClaimedTimeEnd,
		arg.ClaimedTimeText,
		arg.ClaimedGeoRegion,
		arg.ClaimedGeoText,
		arg.ClaimedBy,
	)
	var i Provenance
	err := row.Scan(
		&i.ID,
		&i.TargetType,
		&i.TargetID,
		&i.SourceID,
		&i.Excerpt,
		&i.Location,
		&i.Confidence,
		&i.Trust,
		&i.Status,
		&i.Modality,
		&i.ClaimedTimeStart,
		&i.ClaimedTimeEnd,
		&i.ClaimedTimeText,
		&i.ClaimedGeoRegion,
		&i.ClaimedGeoText,
		&i.ClaimedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteProvenance = `-- name: DeleteProvenance :exec
DELETE FROM provenance
WHERE id = $1
`

func (q *Queries) DeleteProvenance(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProvenance, id)
	return err
}

const getProvenance = `-- name: GetProvenance :one
SELECT id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at FROM provenance
WHERE id = $1
`

func (q *Queries) GetProvenance(ctx context.Context, id pgtype.UUID) (*Provenance, error) {
	row := q.db.QueryRow(ctx, getProvenance, id)
	var i Provenance
	err := row.Scan(
		&i.ID,
		&i.TargetType,
		&i.TargetID,
		&i.SourceID,
		&i.Excerpt,
		&i.Location,
		&i.Confidence,
		&i.Trust,
		&i.Status,
		&i.Modality,
		&i.ClaimedTimeStart,
		&i.ClaimedTimeEnd,
		&i.ClaimedTimeText,
		&i.ClaimedGeoRegion,
		&i.ClaimedGeoText,
		&i.ClaimedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listProvenanceBySource = `-- name: ListProvenanceBySource :many
SELECT id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at FROM provenance
WHERE source_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProvenanceBySource(ctx context.Context, sourceID pgtype.UUID) ([]*Provenance, error) {
	rows, err := q.db.Query(ctx, listProvenanceBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Provenance{}
	for rows.Next() {
		var i Provenance
		if err := rows.Scan(
			&i.ID,
			&i.TargetType,
			&i.TargetID,
			&i.SourceID,
			&i.Excerpt,
			&i.Location,
			&i.Confidence,
			&i.Trust,
			&i.Status,
			&i.Modality,
			&i.ClaimedTimeStart,
			&i.ClaimedTimeEnd,
			&i.ClaimedTimeText,
			&i.ClaimedGeoRegion,
			&i.ClaimedGeoText,
			&i.ClaimedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvenanceByStatus = `-- name: ListProvenanceByStatus :many
SELECT id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at FROM provenance
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProvenanceByStatus(ctx context.Context, status string) ([]*Provenance, error) {
	rows, err := q.db.Query(ctx, listProvenanceByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Provenance{}
	for rows.Next() {
		var i Provenance
		if err := rows.Scan(
			&i.ID,
			&i.TargetType,
			&i.TargetID,
			&i.SourceID,
			&i.Excerpt,
			&i.Location,
			&i.Confidence,
			&i.Trust,
			&i.Status,
			&i.Modality,
			&i.ClaimedTimeStart,
			&i.ClaimedTimeEnd,
			&i.ClaimedTimeText,
			&i.ClaimedGeoRegion,
			&i.ClaimedGeoText,
			&i.ClaimedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvenanceByTarget = `-- name: ListProvenanceByTarget :many
SELECT id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at FROM provenance
WHERE target_type = $1 AND target_id = $2
ORDER BY created_at DESC
`

type ListProvenanceByTargetParams struct {
	TargetType string      `json:"target_type"`
	TargetID   pgtype.UUID `json:"target_id"`
}

func (q *Queries) ListProvenanceByTarget(ctx context.Context, arg ListProvenanceByTargetParams) ([]*Provenance, error) {
	rows, err := q.db.Query(ctx, listProvenanceByTarget, arg.TargetType, arg.TargetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Provenance{}
	for rows.Next() {
		var i Provenance
		if err := rows.Scan(
			&i.ID,
			&i.TargetType,
			&i.TargetID,
			&i.SourceID,
			&i.Excerpt,
			&i.Location,
			&i.Confidence,
			&i.Trust,
			&i.Status,
			&i.Modality,
			&i.ClaimedTimeStart,
			&i.ClaimedTimeEnd,
			&i.ClaimedTimeText,
			&i.ClaimedGeoRegion,
			&i.ClaimedGeoText,
			&i.ClaimedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProvenance = `-- name: UpdateProvenance :one
UPDATE provenance
SET excerpt = $2,
    location = $3,
    confidence = $4,
    trust = $5,
    status = $6,
    modality = $7,
    claimed_time_start = $8,
    claimed_time_end = $9,
    claimed_time_text = $10,
    claimed_geo_region = $11,
    claimed_geo_text = $12
WHERE id = $1
RETURNING id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at
`

type UpdateProvenanceParams struct {
	ID               pgtype.UUID        `json:"id"`
	Excerpt          string             `json:"excerpt"`
	Location         []byte             `json:"location"`
	Confidence       float32            `json:"confidence"`
	Trust            float32            `json:"trust"`
	Status           string             `json:"status"`
	Modality         string             `json:"modality"`
	ClaimedTimeStart pgtype.Timestamptz `json:"claimed_time_start"`
	ClaimedTimeEnd   pgtype.Timestamptz `json:"claimed_time_end"`
	ClaimedTimeText  pgtype.Text        `json:"claimed_time_text"`
	ClaimedGeoRegion pgtype.Text        `json:"claimed_geo_region"`
	ClaimedGeoText   pgtype.Text        `json:"claimed_geo_text"`
}

func (q *Queries) UpdateProvenance(ctx context.Context, arg UpdateProvenanceParams) (*Provenance, error) {
	row := q.db.QueryRow(ctx, updateProvenance,
		arg.ID,
		arg.Excerpt,
		arg.Location,
		arg.Confidence,
		arg.Trust,
		arg.Status,
		arg.Modality,
		arg.ClaimedTimeStart,
		arg.ClaimedTimeEnd,
		arg.ClaimedTimeText,
		arg.ClaimedGeoRegion,
		arg.ClaimedGeoText,
	)
	var i Provenance
	err := row.Scan(
		&i.ID,
		&i.TargetType,
		&i.TargetID,
		&i.SourceID,
		&i.Excerpt,
		&i.Location,
		&i.Confidence,
		&i.Trust,
		&i.Status,
		&i.Modality,
		&i.ClaimedTimeStart,
		&i.ClaimedTimeEnd,
		&i.ClaimedTimeText,
		&i.ClaimedGeoRegion,
		&i.ClaimedGeoText,
		&i.ClaimedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateProvenanceStatus = `-- name: UpdateProvenanceStatus :one
UPDATE provenance
SET status = $2
WHERE id = $1
RETURNING id, target_type, target_id, source_id, excerpt, location, confidence, trust, status, modality, claimed_time_start, claimed_time_end, claimed_time_text, claimed_geo_region, claimed_geo_text, claimed_by, created_at, updated_at
`

type UpdateProvenanceStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateProvenanceStatus(ctx context.Context, arg UpdateProvenanceStatusParams) (*Provenance, error) {
	row := q.db.QueryRow(ctx, updateProvenanceStatus, arg.ID, arg.Status)
	var i Provenance
	err := row.Scan(
		&i.ID,
		&i.TargetType,
		&i.TargetID,
		&i.SourceID,
		&i.Excerpt,
		&i.Location,
		&i.Confidence,
		&i.Trust,
		&i.Status,
		&i.Modality,
		&i.ClaimedTimeStart,
		&i.ClaimedTimeEnd,
		&i.ClaimedTimeText,
		&i.ClaimedGeoRegion,
		&i.ClaimedGeoText,
		&i.ClaimedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
