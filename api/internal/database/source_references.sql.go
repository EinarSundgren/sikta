// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: source_references.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSourceReference = `-- name: CreateSourceReference :one
INSERT INTO source_references (
    chunk_id, claim_id, entity_id, relationship_id, excerpt, char_start, char_end
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, chunk_id, claim_id, entity_id, relationship_id, excerpt, char_start, char_end, created_at
`

type CreateSourceReferenceParams struct {
	ChunkID        pgtype.UUID `json:"chunk_id"`
	ClaimID        pgtype.UUID `json:"claim_id"`
	EntityID       pgtype.UUID `json:"entity_id"`
	RelationshipID pgtype.UUID `json:"relationship_id"`
	Excerpt        string      `json:"excerpt"`
	CharStart      pgtype.Int4 `json:"char_start"`
	CharEnd        pgtype.Int4 `json:"char_end"`
}

func (q *Queries) CreateSourceReference(ctx context.Context, arg CreateSourceReferenceParams) (*SourceReference, error) {
	row := q.db.QueryRow(ctx, createSourceReference,
		arg.ChunkID,
		arg.ClaimID,
		arg.EntityID,
		arg.RelationshipID,
		arg.Excerpt,
		arg.CharStart,
		arg.CharEnd,
	)
	var i SourceReference
	err := row.Scan(
		&i.ID,
		&i.ChunkID,
		&i.ClaimID,
		&i.EntityID,
		&i.RelationshipID,
		&i.Excerpt,
		&i.CharStart,
		&i.CharEnd,
		&i.CreatedAt,
	)
	return &i, err
}

const listSourceReferencesByClaim = `-- name: ListSourceReferencesByClaim :many
SELECT sr.id, sr.chunk_id, sr.claim_id, sr.entity_id, sr.relationship_id, sr.excerpt, sr.char_start, sr.char_end, sr.created_at, c.chapter_title, c.chapter_number
FROM source_references sr
JOIN chunks c ON sr.chunk_id = c.id
WHERE sr.claim_id = $1
`

type ListSourceReferencesByClaimRow struct {
	ID             pgtype.UUID        `json:"id"`
	ChunkID        pgtype.UUID        `json:"chunk_id"`
	ClaimID        pgtype.UUID        `json:"claim_id"`
	EntityID       pgtype.UUID        `json:"entity_id"`
	RelationshipID pgtype.UUID        `json:"relationship_id"`
	Excerpt        string             `json:"excerpt"`
	CharStart      pgtype.Int4        `json:"char_start"`
	CharEnd        pgtype.Int4        `json:"char_end"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ChapterTitle   pgtype.Text        `json:"chapter_title"`
	ChapterNumber  pgtype.Int4        `json:"chapter_number"`
}

func (q *Queries) ListSourceReferencesByClaim(ctx context.Context, claimID pgtype.UUID) ([]*ListSourceReferencesByClaimRow, error) {
	rows, err := q.db.Query(ctx, listSourceReferencesByClaim, claimID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSourceReferencesByClaimRow{}
	for rows.Next() {
		var i ListSourceReferencesByClaimRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.ClaimID,
			&i.EntityID,
			&i.RelationshipID,
			&i.Excerpt,
			&i.CharStart,
			&i.CharEnd,
			&i.CreatedAt,
			&i.ChapterTitle,
			&i.ChapterNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourceReferencesByEntity = `-- name: ListSourceReferencesByEntity :many
SELECT sr.id, sr.chunk_id, sr.claim_id, sr.entity_id, sr.relationship_id, sr.excerpt, sr.char_start, sr.char_end, sr.created_at, c.chapter_title, c.chapter_number
FROM source_references sr
JOIN chunks c ON sr.chunk_id = c.id
WHERE sr.entity_id = $1
`

type ListSourceReferencesByEntityRow struct {
	ID             pgtype.UUID        `json:"id"`
	ChunkID        pgtype.UUID        `json:"chunk_id"`
	ClaimID        pgtype.UUID        `json:"claim_id"`
	EntityID       pgtype.UUID        `json:"entity_id"`
	RelationshipID pgtype.UUID        `json:"relationship_id"`
	Excerpt        string             `json:"excerpt"`
	CharStart      pgtype.Int4        `json:"char_start"`
	CharEnd        pgtype.Int4        `json:"char_end"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ChapterTitle   pgtype.Text        `json:"chapter_title"`
	ChapterNumber  pgtype.Int4        `json:"chapter_number"`
}

func (q *Queries) ListSourceReferencesByEntity(ctx context.Context, entityID pgtype.UUID) ([]*ListSourceReferencesByEntityRow, error) {
	rows, err := q.db.Query(ctx, listSourceReferencesByEntity, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSourceReferencesByEntityRow{}
	for rows.Next() {
		var i ListSourceReferencesByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.ClaimID,
			&i.EntityID,
			&i.RelationshipID,
			&i.Excerpt,
			&i.CharStart,
			&i.CharEnd,
			&i.CreatedAt,
			&i.ChapterTitle,
			&i.ChapterNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourceReferencesByRelationship = `-- name: ListSourceReferencesByRelationship :many
SELECT sr.id, sr.chunk_id, sr.claim_id, sr.entity_id, sr.relationship_id, sr.excerpt, sr.char_start, sr.char_end, sr.created_at, c.chapter_title, c.chapter_number
FROM source_references sr
JOIN chunks c ON sr.chunk_id = c.id
WHERE sr.relationship_id = $1
`

type ListSourceReferencesByRelationshipRow struct {
	ID             pgtype.UUID        `json:"id"`
	ChunkID        pgtype.UUID        `json:"chunk_id"`
	ClaimID        pgtype.UUID        `json:"claim_id"`
	EntityID       pgtype.UUID        `json:"entity_id"`
	RelationshipID pgtype.UUID        `json:"relationship_id"`
	Excerpt        string             `json:"excerpt"`
	CharStart      pgtype.Int4        `json:"char_start"`
	CharEnd        pgtype.Int4        `json:"char_end"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ChapterTitle   pgtype.Text        `json:"chapter_title"`
	ChapterNumber  pgtype.Int4        `json:"chapter_number"`
}

func (q *Queries) ListSourceReferencesByRelationship(ctx context.Context, relationshipID pgtype.UUID) ([]*ListSourceReferencesByRelationshipRow, error) {
	rows, err := q.db.Query(ctx, listSourceReferencesByRelationship, relationshipID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSourceReferencesByRelationshipRow{}
	for rows.Next() {
		var i ListSourceReferencesByRelationshipRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.ClaimID,
			&i.EntityID,
			&i.RelationshipID,
			&i.Excerpt,
			&i.CharStart,
			&i.CharEnd,
			&i.CreatedAt,
			&i.ChapterTitle,
			&i.ChapterNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
