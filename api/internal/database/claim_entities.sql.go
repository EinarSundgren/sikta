// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: claim_entities.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClaimEntity = `-- name: CreateClaimEntity :one
INSERT INTO claim_entities (claim_id, entity_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (claim_id, entity_id) DO UPDATE SET role = EXCLUDED.role
RETURNING claim_id, entity_id, role
`

type CreateClaimEntityParams struct {
	ClaimID  pgtype.UUID `json:"claim_id"`
	EntityID pgtype.UUID `json:"entity_id"`
	Role     pgtype.Text `json:"role"`
}

func (q *Queries) CreateClaimEntity(ctx context.Context, arg CreateClaimEntityParams) (*ClaimEntity, error) {
	row := q.db.QueryRow(ctx, createClaimEntity, arg.ClaimID, arg.EntityID, arg.Role)
	var i ClaimEntity
	err := row.Scan(&i.ClaimID, &i.EntityID, &i.Role)
	return &i, err
}

const listClaimEntities = `-- name: ListClaimEntities :many
SELECT e.id, e.source_id, e.name, e.entity_type, e.aliases, e.description, e.first_appearance_chunk, e.last_appearance_chunk, e.confidence, e.review_status, e.metadata, e.created_at, e.updated_at, ce.role
FROM claim_entities ce
JOIN entities e ON ce.entity_id = e.id
WHERE ce.claim_id = $1
`

type ListClaimEntitiesRow struct {
	ID                   pgtype.UUID        `json:"id"`
	SourceID             pgtype.UUID        `json:"source_id"`
	Name                 string             `json:"name"`
	EntityType           string             `json:"entity_type"`
	Aliases              []string           `json:"aliases"`
	Description          pgtype.Text        `json:"description"`
	FirstAppearanceChunk pgtype.Int4        `json:"first_appearance_chunk"`
	LastAppearanceChunk  pgtype.Int4        `json:"last_appearance_chunk"`
	Confidence           float32            `json:"confidence"`
	ReviewStatus         string             `json:"review_status"`
	Metadata             []byte             `json:"metadata"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	Role                 pgtype.Text        `json:"role"`
}

func (q *Queries) ListClaimEntities(ctx context.Context, claimID pgtype.UUID) ([]*ListClaimEntitiesRow, error) {
	rows, err := q.db.Query(ctx, listClaimEntities, claimID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListClaimEntitiesRow{}
	for rows.Next() {
		var i ListClaimEntitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Name,
			&i.EntityType,
			&i.Aliases,
			&i.Description,
			&i.FirstAppearanceChunk,
			&i.LastAppearanceChunk,
			&i.Confidence,
			&i.ReviewStatus,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClaimEntitiesBySource = `-- name: ListClaimEntitiesBySource :many
SELECT ce.claim_id, e.id AS entity_id, e.name, e.entity_type, ce.role
FROM claim_entities ce
JOIN entities e ON ce.entity_id = e.id
JOIN claims c ON ce.claim_id = c.id
WHERE c.source_id = $1
`

type ListClaimEntitiesBySourceRow struct {
	ClaimID    pgtype.UUID `json:"claim_id"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Name       string      `json:"name"`
	EntityType string      `json:"entity_type"`
	Role       pgtype.Text `json:"role"`
}

func (q *Queries) ListClaimEntitiesBySource(ctx context.Context, sourceID pgtype.UUID) ([]*ListClaimEntitiesBySourceRow, error) {
	rows, err := q.db.Query(ctx, listClaimEntitiesBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListClaimEntitiesBySourceRow{}
	for rows.Next() {
		var i ListClaimEntitiesBySourceRow
		if err := rows.Scan(
			&i.ClaimID,
			&i.EntityID,
			&i.Name,
			&i.EntityType,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntityClaims = `-- name: ListEntityClaims :many
SELECT c.id, c.source_id, c.title, c.description, c.event_type, c.date_text, c.date_start, c.date_end, c.date_precision, c.chronological_position, c.narrative_position, c.confidence, c.confidence_reason, c.review_status, c.metadata, c.created_at, c.updated_at, c.claim_type, ce.role
FROM claim_entities ce
JOIN claims c ON ce.claim_id = c.id
WHERE ce.entity_id = $1
ORDER BY c.narrative_position
`

type ListEntityClaimsRow struct {
	ID                    pgtype.UUID        `json:"id"`
	SourceID              pgtype.UUID        `json:"source_id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	EventType             pgtype.Text        `json:"event_type"`
	DateText              pgtype.Text        `json:"date_text"`
	DateStart             pgtype.Date        `json:"date_start"`
	DateEnd               pgtype.Date        `json:"date_end"`
	DatePrecision         pgtype.Text        `json:"date_precision"`
	ChronologicalPosition pgtype.Int4        `json:"chronological_position"`
	NarrativePosition     int32              `json:"narrative_position"`
	Confidence            float32            `json:"confidence"`
	ConfidenceReason      pgtype.Text        `json:"confidence_reason"`
	ReviewStatus          string             `json:"review_status"`
	Metadata              []byte             `json:"metadata"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ClaimType             string             `json:"claim_type"`
	Role                  pgtype.Text        `json:"role"`
}

func (q *Queries) ListEntityClaims(ctx context.Context, entityID pgtype.UUID) ([]*ListEntityClaimsRow, error) {
	rows, err := q.db.Query(ctx, listEntityClaims, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEntityClaimsRow{}
	for rows.Next() {
		var i ListEntityClaimsRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Title,
			&i.Description,
			&i.EventType,
			&i.DateText,
			&i.DateStart,
			&i.DateEnd,
			&i.DatePrecision,
			&i.ChronologicalPosition,
			&i.NarrativePosition,
			&i.Confidence,
			&i.ConfidenceReason,
			&i.ReviewStatus,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimType,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
