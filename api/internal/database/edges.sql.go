// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: edges.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEdgesByType = `-- name: CountEdgesByType :one
SELECT edge_type, COUNT(*) as count
FROM edges
GROUP BY edge_type
ORDER BY count DESC
`

type CountEdgesByTypeRow struct {
	EdgeType string `json:"edge_type"`
	Count    int64  `json:"count"`
}

func (q *Queries) CountEdgesByType(ctx context.Context) (*CountEdgesByTypeRow, error) {
	row := q.db.QueryRow(ctx, countEdgesByType)
	var i CountEdgesByTypeRow
	err := row.Scan(&i.EdgeType, &i.Count)
	return &i, err
}

const createEdge = `-- name: CreateEdge :one
INSERT INTO edges (edge_type, source_node, target_node, properties, is_negated)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at
`

type CreateEdgeParams struct {
	EdgeType   string      `json:"edge_type"`
	SourceNode pgtype.UUID `json:"source_node"`
	TargetNode pgtype.UUID `json:"target_node"`
	Properties []byte      `json:"properties"`
	IsNegated  bool        `json:"is_negated"`
}

func (q *Queries) CreateEdge(ctx context.Context, arg CreateEdgeParams) (*Edge, error) {
	row := q.db.QueryRow(ctx, createEdge,
		arg.EdgeType,
		arg.SourceNode,
		arg.TargetNode,
		arg.Properties,
		arg.IsNegated,
	)
	var i Edge
	err := row.Scan(
		&i.ID,
		&i.EdgeType,
		&i.SourceNode,
		&i.TargetNode,
		&i.Properties,
		&i.IsNegated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteEdge = `-- name: DeleteEdge :exec
DELETE FROM edges
WHERE id = $1
`

func (q *Queries) DeleteEdge(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEdge, id)
	return err
}

const getEdge = `-- name: GetEdge :one
SELECT id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at FROM edges
WHERE id = $1
`

func (q *Queries) GetEdge(ctx context.Context, id pgtype.UUID) (*Edge, error) {
	row := q.db.QueryRow(ctx, getEdge, id)
	var i Edge
	err := row.Scan(
		&i.ID,
		&i.EdgeType,
		&i.SourceNode,
		&i.TargetNode,
		&i.Properties,
		&i.IsNegated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listEdges = `-- name: ListEdges :many
SELECT id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at FROM edges
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListEdges(ctx context.Context, limit int32) ([]*Edge, error) {
	rows, err := q.db.Query(ctx, listEdges, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Edge{}
	for rows.Next() {
		var i Edge
		if err := rows.Scan(
			&i.ID,
			&i.EdgeType,
			&i.SourceNode,
			&i.TargetNode,
			&i.Properties,
			&i.IsNegated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEdgesByNodes = `-- name: ListEdgesByNodes :many
SELECT id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at FROM edges
WHERE (source_node = $1 AND target_node = $2)
   OR (source_node = $2 AND target_node = $1)
ORDER BY created_at DESC
`

type ListEdgesByNodesParams struct {
	SourceNode pgtype.UUID `json:"source_node"`
	TargetNode pgtype.UUID `json:"target_node"`
}

// Get all edges between two nodes (both directions)
func (q *Queries) ListEdgesByNodes(ctx context.Context, arg ListEdgesByNodesParams) ([]*Edge, error) {
	rows, err := q.db.Query(ctx, listEdgesByNodes, arg.SourceNode, arg.TargetNode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Edge{}
	for rows.Next() {
		var i Edge
		if err := rows.Scan(
			&i.ID,
			&i.EdgeType,
			&i.SourceNode,
			&i.TargetNode,
			&i.Properties,
			&i.IsNegated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEdgesBySource = `-- name: ListEdgesBySource :many
SELECT id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at FROM edges
WHERE source_node = $1
ORDER BY created_at DESC
`

func (q *Queries) ListEdgesBySource(ctx context.Context, sourceNode pgtype.UUID) ([]*Edge, error) {
	rows, err := q.db.Query(ctx, listEdgesBySource, sourceNode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Edge{}
	for rows.Next() {
		var i Edge
		if err := rows.Scan(
			&i.ID,
			&i.EdgeType,
			&i.SourceNode,
			&i.TargetNode,
			&i.Properties,
			&i.IsNegated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEdgesBySourceDocument = `-- name: ListEdgesBySourceDocument :many
SELECT DISTINCT e.id, e.edge_type, e.source_node, e.target_node, e.properties, e.is_negated, e.created_at, e.updated_at
FROM edges e
INNER JOIN provenance p ON p.target_type = 'edge' AND p.target_id = e.id
WHERE p.source_id IN (
    SELECT id FROM nodes
    WHERE node_type = 'document'
    AND properties->>'source_id' = $1::text
)
ORDER BY e.created_at DESC
`

// List all edges that have provenance from a specific source
// First find the document node for this source, then find all edges with provenance from that document
func (q *Queries) ListEdgesBySourceDocument(ctx context.Context, dollar_1 string) ([]*Edge, error) {
	rows, err := q.db.Query(ctx, listEdgesBySourceDocument, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Edge{}
	for rows.Next() {
		var i Edge
		if err := rows.Scan(
			&i.ID,
			&i.EdgeType,
			&i.SourceNode,
			&i.TargetNode,
			&i.Properties,
			&i.IsNegated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEdgesByTarget = `-- name: ListEdgesByTarget :many
SELECT id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at FROM edges
WHERE target_node = $1
ORDER BY created_at DESC
`

func (q *Queries) ListEdgesByTarget(ctx context.Context, targetNode pgtype.UUID) ([]*Edge, error) {
	rows, err := q.db.Query(ctx, listEdgesByTarget, targetNode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Edge{}
	for rows.Next() {
		var i Edge
		if err := rows.Scan(
			&i.ID,
			&i.EdgeType,
			&i.SourceNode,
			&i.TargetNode,
			&i.Properties,
			&i.IsNegated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEdgesByType = `-- name: ListEdgesByType :many
SELECT id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at FROM edges
WHERE edge_type = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListEdgesByTypeParams struct {
	EdgeType string `json:"edge_type"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) ListEdgesByType(ctx context.Context, arg ListEdgesByTypeParams) ([]*Edge, error) {
	rows, err := q.db.Query(ctx, listEdgesByType, arg.EdgeType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Edge{}
	for rows.Next() {
		var i Edge
		if err := rows.Scan(
			&i.ID,
			&i.EdgeType,
			&i.SourceNode,
			&i.TargetNode,
			&i.Properties,
			&i.IsNegated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEdge = `-- name: UpdateEdge :one
UPDATE edges
SET edge_type = $2,
    properties = $3,
    is_negated = $4
WHERE id = $1
RETURNING id, edge_type, source_node, target_node, properties, is_negated, created_at, updated_at
`

type UpdateEdgeParams struct {
	ID         pgtype.UUID `json:"id"`
	EdgeType   string      `json:"edge_type"`
	Properties []byte      `json:"properties"`
	IsNegated  bool        `json:"is_negated"`
}

func (q *Queries) UpdateEdge(ctx context.Context, arg UpdateEdgeParams) (*Edge, error) {
	row := q.db.QueryRow(ctx, updateEdge,
		arg.ID,
		arg.EdgeType,
		arg.Properties,
		arg.IsNegated,
	)
	var i Edge
	err := row.Scan(
		&i.ID,
		&i.EdgeType,
		&i.SourceNode,
		&i.TargetNode,
		&i.Properties,
		&i.IsNegated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
